#!/usr/bin/env python
# coding: utf-8
"""
Utility functions for PDB file operations.
"""

import numpy as np
from openmm import unit


def write_pdb_with_chain_ids(topology, positions, output_file):
    """
    Write a PDB file preserving chain IDs from the topology.
    
    OpenMM's PDBFile.writeFile sometimes reassigns chain IDs, especially
    for non-standard chain IDs like '8'. This function preserves the original
    chain IDs from the topology.
    
    Parameters
    ----------
    topology : openmm.app.topology.Topology
        The topology object containing chain, residue, and atom information
    positions : list or array
        Atomic positions (Vec3 objects or arrays) in nanometers
    output_file : str
        Path to the output PDB file
    """
    with open(output_file, 'w') as f:
        # Write header if needed
        f.write("REMARK   1 Generated by COSMO simulation\n")
        
        atom_serial = 1
        for chain in topology.chains():
            chain_id = chain.id if chain.id else ' '
            last_res_name = None
            last_res_seq = None
            
            for residue in chain.residues():
                res_name = residue.name
                # Try to get residue ID, fall back to index+1
                try:
                    res_seq = int(residue.id) if residue.id else residue.index + 1
                except (ValueError, AttributeError):
                    res_seq = residue.index + 1
                
                last_res_name = res_name
                last_res_seq = res_seq
                
                for atom in residue.atoms():
                    atom_name = atom.name
                    pos = positions[atom.index]
                    
                    # Convert position to Angstroms (OpenMM uses nm internally)
                    # Positions from getState() are Vec3 objects with float components in nm
                    if hasattr(pos, 'x'):
                        # Vec3 object - components are already floats in nm
                        x = float(pos.x) * 10.0  # Convert nm to Angstroms
                        y = float(pos.y) * 10.0
                        z = float(pos.z) * 10.0
                    elif isinstance(pos, (list, tuple, np.ndarray)) and len(pos) >= 3:
                        # List/tuple/array format (already in nm)
                        x = float(pos[0]) * 10.0
                        y = float(pos[1]) * 10.0
                        z = float(pos[2]) * 10.0
                    else:
                        raise ValueError(f"Unexpected position format for atom {atom.index}: {type(pos)}")
                    
                    # Get element symbol
                    element = '  '
                    if hasattr(atom, 'element') and atom.element:
                        element = atom.element.symbol
                    elif atom_name:
                        # Try to infer from atom name
                        element = atom_name[0] if atom_name[0].isalpha() else '  '
                    
                    # Format PDB ATOM line
                    line = (
                        f"ATOM  {atom_serial:5d} {atom_name:^4s} {res_name:>3s} "
                        f"{chain_id:1s}{res_seq:4d}    "
                        f"{x:8.3f}{y:8.3f}{z:8.3f}"
                        f"  1.00  0.00           {element:>2s}\n"
                    )
                    f.write(line)
                    atom_serial += 1
            
            # Write TER record for this chain (if we wrote any atoms)
            if last_res_name is not None:
                f.write(f"TER   {atom_serial:5d}      {last_res_name:>3s} {chain_id:1s}{last_res_seq:4d}\n")
        
        f.write("END\n")
